<?php
/**
 * Provides cryptographically secure random bytes generation
 *
 * @copyright  Based on frostschutz's post at
 *             http://forums.thedailywtf.com/forums/t/16453.aspx
 * @copyright  Copyright (c) 2011 The Fajr authors (see AUTHORS).
 *             Use of this source code is governed by a MIT license that can be
 *             found in the LICENSE file in the project root directory.
 * @package    Fajr
 * @subpackage Fajr
 * @author     frostschutz
 * @author     Peter Perešíni <ppershing+fajr@gmail.com>
 */
namespace fajr\security;

use fajr\libfajr\base\Preconditions;
use COM;
use Exception;
use RuntimeException;

/**
 * Provides api for generating cryptographically strong random bytes.
 *
 * @package    Fajr
 * @subpackage Fajr
 * @author     Peter Perešíni <ppershing+fajr@gmail.com>
 */
class SecureRandom {
  /**
   * File with random bytes.
   *
   * Note: we don't use /dev/random as it may block for a big time.
   * This seems to be not the problem with the security.
   * According to http://lwn.net/Articles/261091/ the urandom security
   * should be quite sufficient.
   */
  const RANDOM_FILE = '/dev/urandom';
  /**
   * Windows cryptoapi COM name.
   */
  const CRYPTOAPI_COM = 'CAPICOM.Utilities.1';

  private static $useOpenssl = true;
  private static $useLinuxRandom = true;
  private static $useWindowsCryptoapi = true;

  /**
   * For internal testing only.
   * @deprecated
   */
  static function __clearUse() {
    self::$useOpenssl = false;
    self::$useLinuxRandom = false;
    self::$useWindowsCryptoapi = false;
  }

  /**
   * Check whether we can generate bytes using open SSL.
   *
   * @returns bool true if openssl is available
   */
  static function _isOpensslAvailable() {
    return self::$useOpenssl && function_exists('openssl_random_pseudo_bytes');
  }

  /**
   * Returns a securely generated random bytes from open SSL.
   *
   * Warning: use SecureRandom::random() instead
   *
   * @param int $count number of random bytes to be generated
   *
   * @returns bytes|false generated bytes or false on error
   */
  static function _randomBytesOpenssl($count) {
    Preconditions::check(is_int($count));
    Preconditions::check($count > 0);

    // TODO(ppershing): check this on windows: from user comments in manual page:
    // FYI, openssl_random_pseudo_bytes() can be incredibly slow under Windows, to the point of being
    // unusable.
    if (!self::_isOpensslAvailable()) {
      throw Exception("OpenSSL not available!");
    }

    $output = openssl_random_pseudo_bytes($count, $strong);

    if ($strong === true) { // openssl claim the random is strong
      return $output;
    }
    return false;
  }

  /**
   * Check whether we can generate bytes using windows crypto api.
   *
   * @returns bool true if windows cryptoapi is available
   */
  static function _isWindowsCryptoapiAvailable() {
    if (!self::$useWindowsCryptoapi ||
        !version_compare(PHP_VERSION, '5.0.0', '>=') || 
        !class_exists('COM', false)) {
      return false;
    }
    // Note(ppershing): there is no documentation on return value
    // bad construction of COM object, but false seems to be the case.
    $tmp = new COM(self::CRYPTOAPI_COM);
    return ($tmp !== false);
  }


  /**
   * Returns a securely generated random bytes from windows cryptoapi.
   *
   * Warning: use SecureRandom::random() instead
   *
   * @param int $count number of random bytes to be generated
   *
   * @returns bytes|false generated bytes or false on error
   */
  static function _randomBytesWindowsCryptoapi($count) {
    Preconditions::check(is_int($count));
    Preconditions::check($count > 0);

    if (!self::_isWindowsCryptoapiAvailable()) {
      throw new Exception("Windows cryptoapi is not available.");
    }

    $util = new COM(self::CRYPTOAPI_COM);
    $base64 = $util->GetRandom($count, 0); // default encoding is base64
    $output = base64_decode($base64, true); // be strict
    return $output;
  }

  /**
   * Check whether we can generate bytes using linux random.
   *
   * @returns bool true if linux random is available
   */
  public static function _isLinuxRandomDevAvailable()
  {
    return self::$useLinuxRandom && @is_readable(self::RANDOM_FILE);
  }

  /**
   * Returns a securely generated random bytes from linux random.
   *
   * Warning: use SecureRandom::random() instead
   *
   * @param int $count number of random bytes to be generated
   *
   * @returns bytes|false generated bytes or false on error
   */
  public static function _randomBytesLinuxRandomDev($count) {
    Preconditions::check(is_int($count));
    Preconditions::check($count > 0);

    if (!self::_isLinuxRandomDevAvailable()) {
      throw new Exception("Linux random device is not available!");
    }

    $handle = @fopen(self::RANDOM_FILE, 'rb');
    $output = @fread($handle, $count);
    @fclose($handle);
    if (strlen($output) !== $count) {
      return false; // oops, some problem reading required number of bytes
    }
    return $output;
  }

  /**
   * Returns a securely generated random *bytes*
   *
   * @param int $count number of random bytes to be generated
   *
   * @returns bytes generated bytes
   * @throws RuntimeException if any error occurs.
   *    Warning: Never catch and ignore exceptions from this function!
   */
  static function random($count)
  {
    Preconditions::check(is_int($count));
    Preconditions::check($count > 0);

    // TODO(ppershing): verify following claim
    // Try the OpenSSL method first. This is the strongest.

    $output = false;
    if (!$output && self::_isOpensslAvailable()) {
      $output = self::_randomBytesOpenssl($count);
    }

    // Then try the unix/linux method
    if (!$output && self::_isLinuxRandomDevAvailable()) {
      $output = self::_randomBytesLinuxRandomDev($count);
    }

    // Then try the Microsoft method
    if (!$output && self::_isWindowsCryptoapiAvailable()) {
      $output = self::_randomBytesWindowsCryptoapi($count);
    }

    // No method was able to generate random bytes.
    // Do not ignore this and throw security error as
    // caller may forgot to check return value.
    if ($output == false) {
      throw new RuntimeException("Unable to generate random bytes.");
    }

    // internal check on sanity
    if (strlen($output) != $count) {
      throw new Exception("Wrong number random bytes were generated. ".
          "This may be a severe internal error in secure random.");
    }

    return $output;
  }
}
